Step 1: Set up the Project Structure
Create a new directory for the project and navigate into it. Create the following subdirectories and files:

markdown

blog_app/
app/
__init__.py
models.py
routes.py
templates/
base.html
home.html
post.html
create_post.html
edit_post.html
static/
style.css
requirements.txt
config.py
run.py

Step 2: Install Dependencies
In the requirements.txt file, add the following dependencies:
Flask
Flask-SQLAlchemy
Flask-Login
Flask-WTF
Run thepip install -r requirements.txt 

Step 3: Configure the Application
In the config.py file, add the following configuration:
import os

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'secret_key'
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'sqlite:///blog.db'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    
Step 4: Create the Database Models
In the models.py file, add the following code:
from flask_sqlalchemy import SQLAlchemy
from flask_login import UserMixin
from werkzeug.security import generate_password_hash, check_password_hash
db = SQLAlchemy()
class User(UserMixin, db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    posts = db.relationship('Post', backref='author', lazy=True)

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(128), nullable=False)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False, default=db.func.current_timestamp())
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    
Step 5: Create the Routes
In the routes.py file, add the following code:
from flask import Flask, render_template, redirect, url_for, flash
from flask_login import login_user, logout_user, login_required, current_user
from app import db
from app.models import User, Post
from app.forms import PostForm

app = Flask(__name__)
app.config.from_object('config.Config')
db.init_app(app)

@app.route('/')
def home():
    posts = Post.query.all()
    return render_template('home.html', posts=posts)

@app.route('/create_post', methods=['GET', 'POST'])
@login_required
def create_post():
    form = PostForm()
    if form.validate_on_submit():
        post = Post(title=form.title.data, content=form.content.data, author=current_user)
        db.session.add(post)
        db.session.commit()
        flash('Post created successfully!')
        return redirect(url_for('home'))
    return render_template('create_post.html', form=form)

@app.route('/post/<int:post_id>')
def post(post_id):
    post = Post.query.get_or_404(post_id)
    return render_template('post.html', post=post)

@app.route('/edit_post/<int:post_id>', methods=['GET', 'POST'])
@login_required
def edit_post(post_id):
    post = Post.query.get_or_404(post_id)
    if post.author != current_user:
        flash('You do not have permission to edit this post!')
        return redirect(url_for('home'))
    form = PostForm(obj=post)
    if form.validate_on_submit():
        form.populate_obj(post)
        db.session.commit()
        flash('Post updated successfully!')
        return redirect(url_for('home'))
    return render_template('edit_post.html', form=form)
    
Step 6: Create the Templates
Create the following templates:

'base.html':
<!DOCTYPE html>
<html>
<head>
    <title>Blog App</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <nav>
        <ul>
            <li><a href="{{ url_for('home') }}">Home</a></li>
            <li><a href="{{ url_for('create_post') }}">Create Post</a></li>
            {% if current_user.is_authenticated %}
                <li><a href="{{ url_for('logout') }}">Logout</a></li>
            {% else %}
                <
                
Step 7: Implement User Authentication
In the routes.py file, add the following code:
@app.route('/register', methods=['GET', 'POST'])
def register():
    if current_user.is_authenticated:
        return redirect(url_for('home'))
    form = RegistrationForm()
    if form.validate_on_submit():
        user = User(username=form.username.data, password=form.password.data)
        db.session.add(user)
        db.session.commit()
        flash('User created successfully!')
        return redirect(url_for('login'))
    return render_template('register.html', form=form)

@app.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('home'))
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user and user.check_password(form.password.data):
            login_user(user)
            flash('Logged in successfully!')
            return redirect(url_for('home'))
    return render_template('login.html', form=form)

@app.route('/logout')
@login_required
def logout():
    logout_user()
    flash('Logged out successfully!')
    return redirect(url_for('home'))
    
Step 8: Implement Delete Post Feature
In the routes.py file, add the following code:
@app.route('/delete_post/<int:post_id>', methods=['POST'])
@login_required
def delete_post(post_id):
    post = Post.query.get_or_404(post_id)
    if post.author != current_user:
        flash('You do not have permission to delete this post!')
        return redirect(url_for('home'))
    db.session.delete(post)
    db.session.commit()
    flash('Post deleted successfully!')
    return redirect(url_for('home'))
    
Step 9: Add Pagination and Filtering
To add pagination, we can use the paginate function from Flask-SQLAlchemy. In the routes.py file, update the home function:
@app.route('/')
def home():
    page = request.args.get('page', 1, type=int)
    posts = Post.query.paginate(page=page, per_page=10, error_out=False)
    return render_template('home.html', posts=posts)
To add filtering by tag, we can create a new model for tags and update the Post model to include a many-to-many relationship with tags. In the models.py file, add the following code:
class Tag(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True, nullable=False)

class Post(db.Model):
    # ...
    tags = db.relationship('Tag', secondary='post_tags', backref=db.backref('posts', lazy=True))

post_tags = db.Table('post_tags',
    db.Column('post_id', db.Integer, db.ForeignKey('post.id')),
    db.Column('tag_id', db.Integer, db.ForeignKey('tag.id'))
)
In the routes.py file, update the home function to include filtering by tag:
@app.route('/')
def home():
    page = request.args.get('page', 1, type=int)
    tag_id = request.args.get('tag_id', None, type=int)
    if tag_id:
        posts = Post.query.join(Post.tags).filter(Tag.id == tag_id).paginate(page=page, per_page=10, error_out=False)
    else:
        posts = Post.query.paginate(page=page, per_page=10, error_out=False)
    return render_template('home.html', posts=posts)
    
Step 10: Implement Search Feature
To implement a basic search feature, we can add a search form to the base.html template and update the routes.py file to handle search queries. In the routes.py file, add the following code:
@app.route('/search', methods=['GET', 'POST'])
def search():
    form = SearchForm()
    if form.validate_on_submit():
        query = form.query.data
        posts = Post.query.filter(Post.title.like('%' + query + '%') | Post.content.like('%' + query + '%')).all()
        return render_template('search.html', posts=posts, query=query)
    return render_template('search.html', form=form)
    
This is a basic implementation of the blog application. You can enhance it further by adding more features, styling, and functionality.
